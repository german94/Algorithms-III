\documentclass{article}
\usepackage{algorithmicx}
\usepackage{algpseudocode}


\begin{document}
{\noindent \Huge Problema a resolver:}
\newline \newline  Una empresa transportadora de productos qu\'imicos cuenta con una cantidad finita n de distintos productos, para ser transportados en camiones.  Para cada par de productos $P_{ij}$  con $i\neq j$  y  $1\leq i, j\leq n $ se posee un determinado coeficiente de peligrosidad $\alpha(i,j)$ (la peligrosidad del producto i con j es reciproca a la de j con i) que se activa cuando dichos productos están en un mismo cami\'on, cada producto por si solo no posee ninguna peligrosidad. 
	Debido a las normas de seguridad vigente, en cada cami\'on la suma total de los coeficientes de peligrosidad  de los pares de productos H(P), siendo P el conjunto de elementos en un cami\'on,  no debe exceder un umbral M entero positivo. Es decir 
$H(P) = \sum \alpha(i,j) \leq M$
Teniendo esto en cuenta,  se desea  distribuir los productos en cierta cantidad de camiones de manera que la cantidad utilizada sea la m\'inima. A lo que llamaremos soluci\'on \'optima del problema \newline


Ejemplo 1:\newline
sea n = 1; M = m ;\newline
	En el caso que la cantidad de productos a transportar sea solamente uno. Como cada par de  producto por si solo no presenta ninguna peligrosidad y siendo P el conjunto que incluye a este \'unico producto entonces $H(P) = 0$ como m es un entero positivo tenemos que $H(P) <= m$. En estos casos sin importar el valor de m; La soluci\'on \'optima es utilizar un \'unico cami\'on.\newline

Ejemplo 2:\newline
sea $n > 1$; M = m; \newline
	Si cada para cada par de productos $P_i$ $P_j$ con $i\neq j$, $1\leq i,j\leq n$ y $\alpha(i,j) > M$.
Entonces sin importar las combinaciones de conjuntos de producto que haga en un camión. Siempre se supera el umbral. Entonces si coloco al producto i en un primer cami\'on, para todos los productos restantes se tendrá el mismo problema, siguiendo esta lógica con los restantes productos  se tendrá que  colocar a cada uno en un cami\'on distinto. Por lo que en conclusión se tendr\'an tantos camiones como productos. Y esa sera la \'unica soluci\'on \'optima.\newline


Ejemplo 3:  \newline
sea $n >1$ ; M=m; \newline
Sea P el conjunto con los n productos si $H(P)\leq m$ entonces todo los productos pueden ser ubicados en un solo cami\'on. Para estos casos un solo cami\'on es la \'optima soluci\'on. \newline


Ejemplo 4 \newline
n = 4;  M = 12;   \newline
$\alpha(1, 2) = 4$; $\alpha(1, 3) =  7$; $\alpha(1, 4) = 13$ 
; $\alpha(2, 3) =  6$; $\alpha(2, 4) = 5$; 
$\alpha(3, 4) = 1$;
En este caso debido a que $\alpha(1,4) > M$ se van a necesitar mas de un camión como mínimo ya que si tengo uno solo al momento de ubicar a $P_1$ con $P_4$ se superara el umbral.
Por lo que por el momento se van a utilizar dos camiones, A y B, donde A contiene a $P_1$ y B a $P_4$ (tambi\'en se podr\'ian cambiar la ubicaci\'on de los productos pero el fin es el mismo). Ahora quedan por ubicar dos productos $P_2$ y $P_3$. Una posible soluci\'on \'optima seria ubicar a $P_2$ en A y $P_3$ en B. De
esta forma el coeficiente de peligrosidad total en el cami\'on A  quedaría H(1,2) = 4 que es menor estricto a M y en B H(3,4) = 1 tambien menor a M pero, no es la \'unica soluci\'on \'optima posible. Si se ubica a $P_3$ en A quedar\i'a H(1,3) = 7, y en B a $P_2$ con $P_4$ quedar\'ia H(2,4) = 5. Incluso otra posible opci\'on es 
ubicar en el cami\'on B a los productos $P_2$, $P_3$ junto  con $P_4$ de esta forma quedar\'ia $H(P) = 12 < M$  y en otro cami\'on solo $P_1$;\newline  \newline 



{\noindent \Huge Resoluci\'on:}
\newline \newline

Se debe devolver la cantidad de camiones utilizados de manera que sea una \'optima soluci\'on para el problema, e indicando que producto transporta cada uno. Los par\'ametros de entrada constan de un umbral M, un entero n que representa la cantidad de productos a transportar y los coeficientes de peligrosidad entre los pares de elementos. Para poder acceder a estos valores se va a proceder a crear de manera din\'amica un arreglo de arreglos de enteros, es decir una matriz donde cada posici\'on representa el coeficiente de peligrosidad entre pares de  elementos a la que llamaremos \textit{peligrosidades}. Debido a que se indexa desde el valor cero y la cantidad de productos es un entero mayor o igual a uno. Para todo i, j con $0 \leq i,j \leq n$, \textit{peligrosidades[i][j]} representa el coeficiente de peligrosidad entre los productos $P_{i+1}$ y $P_{j+1}$. \newline
	 Luego se va a proceder a construir un vector de tuplas. La primer componente de cada tupla es un vector de productos y la segunda es un valor entero que representa la suma total de los coeficientes de peligrosidad de los productos presentes en la primer componente. Este vector sera denominado \textit{camiones}, debido a que cada componente, cada tupla, emula un cami\'on indicando los elementos presentes en el mismo y su peligrosidad actual. Como consecuencia el tama\~no del vector \textit{camiones} representara la cantidad de camiones utilizado.  \newline
	Con el objetivo de obtener la m\'inima cantidad de camiones se empezara agregando al vector \textit{camiones} una tupla que representa el primer cami\'on, y se vera si es posible ubicar todos los productos de manera que la suma total de los coeficientes no supere el umbral. De no ser posible, se creara una nueva tupla en el vector \textit{camiones}. Representando un nuevo cami\'on disponible, nuevamente se analizara si todos los productos pueden ser distribuidos en la nueva cantidad de camiones disponibles, hasta que todos puedan ser distribuidos y esta sera una de las posibles soluciones \'optimas del problema. Para lograr esto en primer lugar se ubicara en la primer componente de la tupla creada a $P_1$(se ubica al producto al final del vector) y la segunda componente tendr\'a el valor cero ya que por ahora nuestro cami\'on solo posee un \'unico elemento y la peligrosidad solo se manifiesta de a pares de elementos. Ahora se llamara a otra funci\'on para que siga acomodando los productos restantes, denotada como \textit{ubicar\_siguientes\_productos}.  Dicha funció\'on cuenta con varios par\'ametros de entrada, el valor del umbral, necesario para poder saber que elementos voy a poder meter en un cami\'on; la cantidad total de productos, \textit{cantidad\_total} ; el producto  que ahora tengo que ubicar, \textit{producto\_actual}; la matriz con las peligrosidades, la cantidad de cami\'on disponibles actualmente,\textit{camiones\_disponibles}; Y el parametro de salida de esta funci\'on sera un valor booleano que indica si termine de ubicar a todos los productos, en este caso el valor sera True, en caso de no terminar sera False. \newline
	 Luego de llamar a \textit{ubicar\_siguientes\_productos} pueden ocurrir dos cosas: \newline \newline
1) el valor de \textit{producto\_actual} es menor o igual que el de \textit{producto\_totales} esto significa que aun tengo productos sin ubicar.  Lo que se va a proceder a hacer es mediante una nueva funcion, \textit{agregar\_producto\_a\_un\_camion}, verificar si puede ser ubicado en algunos de los camiones disponibles, para esto se le pasara por parametro las peligrosidades, la tupla de \textit{camiones} en la cual quiero comprobar si puedo agregar a \textit{producto\_actual} y al \textit{producto\_actual}. Para esta comprobaci\'on se comenzara por la primera de las tuplas disponibles. La funci\'on comparara si el coeficiente de peligrosidad del \textit{producto\_actual} con el primero de los presentes en el vector de la tupla pasada como parametro, sumada a la segunda componente excede el umbral. Si no lo hace se procede a realizar el mismo an\'alisis con el siguiente producto del vector pero, en este caso la suma de peligrosidades contempla la peligrosidad de \textit{producto\_actual} con el o los anteriores del vector. Si ya no hay elementos que analizar y la suma total es menor o igual que M. se agrega al elemento en el cami\'on actual. Se actualiza el valor de la segunda componente de la tupla al valor que representa agregar a \textit{producto\_actual} y se lo agrega atr\'as en el vector. Se llama a \textit{ubicar\_siguientes\_productos}. Pero ahora con el siguiente producto. Es decir, incrementando en uno el valor de la variable \textit{producto\_actual}. \newline
En el caso de que no se pueda agregar a \textit{producto\_actual} en el cami\'on actual se lo intentara ubicar en el pr\'oximo   (si es que existe un siguiente), es decir en el siguiente elemento del vector \textit{camiones}. En el caso de existir un siguiente. Se procede a realizar lo mismo es decir verificar si puedo agregarlo al siguiente cami\'on. Si ya no tengo camiones disponibles y estoy tratando de ubicar a $P_k$ con $n \geq k \geq 2$ entonces se procede a remover al producto anterior es decir a $P_{k-1}$ del  iesimo-camion (como este fue el \'ultimo producto agregado y siempre se lo agrega atr\'as del vector, solo se debe retirar el \'ultimo elemento cuando ocurran estos casos) en el que se encuentra ya que la ubicaci\'on en ese cami\'on no me permite ubicar luego a $P_k$ . En caso de haber un siguiente cami\'on y si es posible (mediante el uso de la funcion \textit{agregar\_producto\_a\_un\_camion} ) se lo ubica ah\'i. Y se procede a intentar ubicar a $P_k$ nuevamente desde el primer cami\'on. En el caso de que para $P_{k-1}$ no tenga un siguiente cami\'on se proceder\'a a remover al producto $P_{k-2}$ y asi hasta que si el producto que debo remover es el  primero ($P_1$) entonces  verificara el valor de verdad de las llamadas recursivas a la funcio\'on \textit{ubicar\_siguientes\_productos} de ser true se procede a mostrar el resultado. Sino, significa que con la cantidad de camiones disponibles actualmente no existe ninguna combinaci\'on que no exceda el umbral por lo que se va a retirar al producto $P_1$ del cami\'on actual para luego crear una nueva tupla que funciona como un nuevo cami\'on. Se agrega a $P_1$ en el nuevo y se volvera a aplicar la misma idea es decir se llamara a  \textit{ubicar\_siguientes\_productos} pero ahora con el valor de la variable \textit{camiones\_disponibles} incrementado en uno. \newline \newline
2) el valor de \textit{producto\_actual} supera al de \textit{cantidad\_total} de elementos,esto significa que ya ubique a todos por lo que debo devolver los elementos de cada tupla del vector \textit{camiones}. Donde la posicion de los elementos en el vector representa en que camion seran transportados y el tama\~no de \textit{camiones} es la cantidad total de camiones utilizados.\newline
A continuaci\'on, se presenta el pseudoc\'odigo de la idea descripta anteriormente:
\vspace{0.4cm}
\begin{algorithmic}[1]
\Procedure{ubicar\_producto}{$umbral,cantidad\_total, peligrosidades$}
	\State $producto\_actual \gets 1$
	\State $camiones\_disponibles \gets 1$
	\State $termine \gets false$
	\State $camiones \gets crear Vector(tupla(vector, int))$
	\While{$(!termine)$}
		\State $camion \gets crear(tupla(vector, int))$
		\State $AgreagarAtras(camion.\pi_1,  elemento\_actual)$
		\State $camion.\pi_2 \gets 0$
		\State $AgreagarAtras(camiones, camion)$
		\State $termine \gets ubicar\_siguientes\_productos$
		\If{$(termine)$}
			\State $return$ $camiones $
		\Else 
			\State{$Sacar(P_1, camiones[camiones\_disponibles])$}
			\State $camiones\_disponibles++$
		\EndIf	
	\EndWhile
\EndProcedure
\end{algorithmic}

\vspace{0.4cm}
\begin{algorithmic}[1]
\Procedure{ubicar\_siguientes\_productos}{$umbral, cantidad\_total, producto\_actual, camiones_disponibles, camiones, peligrosidades$}
	\If{($producto\_actual > cantidad\_total$)}
		\State $return$ $True$
	\Else
		\State $termine \gets false$
		\State $i \gets 0$
		\While{$(i \leq camiones\_disponibles)$}	
			\If{$(agrego\_producto(producto\_actual, camiones[i]))$}	
				\State $termine \gets ubicar\_siguientes\_productos$ 
				\If{$(termine)$}
					\State $return$ $termine$
				\Else
					\State $sacar(producto\_actual, camiones[i])$
				\EndIf
			\EndIf
			\State $i++$
		\EndWhile						
	\EndIf
\EndProcedure
\end{algorithmic}

\vspace{1.5cm}
{\noindent \Huge Complejidad temporal:}
\newline \newline

Para la resoluci\'on del ejercicio se utilizo las clases std::pair y std::vector provistas por la stl*. En el caso del vector las operaciones utilizadas fueron $push\_back$ , $pop\_back$ y acceso aleatorio. La complejidad de las mismas son:\newline
En el caso de Acceso aleatorio  O(1)* \newline
Inserci\'on o extracci\'on de elementos al final , O(1) constante amortizado*. \newline
Como se a descripto en la parte de \textit{resoluci\'on} solo se insertan elementos al final del vector y se retiran siempre los \'ultimos. La complejidad total puede ser calculada a partir de la suma de las siguientes: \newline \newline
1) Fue necesario armar una matriz con los coeficientes de peligrosidad de cada par de elemento. Sean n productos, se obtiene una matriz de tama\~no $n^{2}$ (si bien el coeficiente de peligrosidad entre los pares de productos i, j, $1 \leq i,j \leq n$  es el mismo que el de j, i. Tener toda la matriz completa es mas productivo a los fines de resolver el ejercicio y poder acceder a los valores). Dicha matriz contiene enteros que representan la peligrosidad, por lo que su creaci\'on es 0($n^{2}$) y completar con los valores demora un ciclo que va desde cero hasta n, para recorrer las filas, que contiene otro ciclo con el mismo rango. Solo que este recorre las columnas. De esta forma completar los datos toma O($n^{2}$).  \newline

2) Para saber en que camiones se encuentran los productos ya ubicados se creo el vector  de tuplas. A lo que llamamos \textit{camiones} en la parte de \textit{Resoluci\'on} del problema. \newline
 La resoluci\'on se basa en dos funciones principales \textit{ubicar\_producto} y \newline
\textit{ubicar\_siguientes\_productos}. La primera es la responsable de crear las tuplas del vector \textit{camiones} y ubicar al primer producto ($P_1$). Una vez ubicado se llama a la funcion \textit{ubicar\_siguientes\_productos} que como su nombre lo indica, se encargara de intentar distribuir los siguientes productos, en el total de camiones creados hasta el momento. Cada vez que se crea un cami\'on se ve si hay alguna combinaci\'on posible para ubicar los productos. Por lo que la funci\'on \textit{agregar\_producto} realizara a lo sumo n interaciones, y es cuando cada cami\'on debe tranportar un solo producto. En cada una de ellas adem\'as de llamar a \textit{ubicar\_siguientes\_produtos}, se crearan tantas tuplas como sean necesarias. La creaci\'on de cada una es en O(1). A lo sumo son posibles crear n, que es cuando cada cami\'on si o si debe transportar a un \'unico producto entonces, en el peor caso tiene complejidad:
\[
\sum_{cantidad\_de\_tuplas=1}^{n}{O(1)}= O(n)
\]

Ademas se agregara atr\'as (\textit{Push\_back}) en el vector de la misma a $P_1$, O(1). En el caso que esta no sea la primer tupla del vector, se lo retirara del final del vector de la anterior tupla (\textit{pop\_back}), retirarlo cuesta O(1).\newline 

3) Cada vez que se llama a la funci\'on \textit{ubicar\_siguientes\_productos} se  intenta ubicar al denominado \textit{producto\_actual} de esa instancia. Para esto se realiza un while que va a verificar desde la primer tupla hasta la \'ultima creada si se puede ubicar al producto. Si c es la cantidad de camiones creados entonces, se realizan c iteraciones. Pero en cada una se comprobara si el iesimo cami\'on que se esta verificando es una posici\'on valida(m\'as adelante se detalla como influye esta verificaci\'on). Si es posible ubicar al producto entonces, se llama de nuevo a la funcion \textit{ubicar\_siguientes\_productos} pero ahora con \textit{producto\_actual} incrementado. Y se procedera con la misma idea hasta que  se ubiquen a todos los productos, o hasta que para alguno se llegue a recorrer los c camiones y no pueda ser ubicado en ninguno. Si esto ocurre entonces, supongamos que el producto $P_k$ es el que no se pudo ubicar. Se procede a retirar al producto $P_{k-1}$ al siguiente posible. Si se lo ubico, $P_k$ tiene nuevamente c posibles ubicaciones. Es decir, se ejecuta un ciclo dentro de otro. Cada uno en un rango c. Por lo que la cantidad de movimientos totales es: \newline
\[
\sum_{P_n=1}^{c}\sum_{P_{n-2}=1}^{c}...... \sum_{P_1=1}^{c} 1 = c^{c}
\]
Donde la sumatoria con el \'indice $P_i$, $1\leq i\leq n$, indica cuantos movimientos se realizaro en total hasta el producto $P_i$ con una cantidad c de camiones. Donde el peor caso esta determinado cuando c = n. Esto significa que cada producto debe ir solo. \newline

4) Como se menciono, para determinar si un producto puede ser ubicado en un cami\'on se utiliza la funci\'on \textit{agrego\_producto}. Como ya se tiene calculado, en la segunda componente de cada tupla del vector \textit{camiones}, la suma de los coeficientes totales de los productos que se encuentran en el vector. Lo \'unico que se hace es mediante un ciclo que comienza desde el primero de los elementos ya ubicados. Sumar el coeficiente del nuevo producto a la segunda componente y en cada iteracion ver si se supera el umbral. En caso de superarse se interrumpe el ciclo en la iesima iteracion que se este realizando. Y si se puede agregar el elemento es que luego de todo el ciclo el umbral no se supero en este caso siempre se realizan tantas iteraciones como productos haya en la tupla y en cada iteracion solo se realizan operaciones aritmeticas y asignaciones.
De esta forma si estamos intentando ubicar al producto $P_k$, significa que ya ubicamos k-1 productos por lo que la cantidad de iteraciones son a lo sumo k-1 es decir tiene complejidad O(k). Pero la cantidad de elementos se encuentra distribuido a lo largo de todos los camiones disponibles entonces se debe recorrer cada tupla, O(c). Por lo que determinar donde ubicar un elemento cuesta: \newline
O(k) + (c),(recorrer todo el vector \textit{camiones} y realizar k operaciones aritmeticas para determinar si un elemento se puede ubicar) en el peor caso hay tantos camiones como productos. si acotamos k por n que es el maximo valor que puede alcanzar k entonces, la complejidad de comprobar es O(n) + O(n) = O(n).
Pero esta comprobacion se hace para todos los movimientos entonces la complejidad queda $n.n^{n}$ (verificaci\'on por el total de movimientos). \newline \newline Finalmente la complejidad total es: \newline
O($n^{2}$) + O($n^{2}$) + O($n^{n+1}$) (crear la matriz, completarla, crear el vector de tuplas, y la verificaci\'on por la cantidad de veces que se realiza) \newline = O($n^{2}$) + O($n^{n+1}$) =
O($n^{2}$).O($n^{n-1}$ + 1) = O($n^{2}$).O($n^{n-1}$) = O($n^{n+1}$)  
\end{document}